import 'package:flutter/material.dart';
import '../../domain/entities/event.dart';
import '../../domain/entities/event_invitation.dart';
import '../../domain/usecases/get_events.dart';
import '../../domain/usecases/get_event.dart';
import '../../domain/usecases/create_event.dart';
import '../../domain/usecases/update_event.dart';
import '../../domain/usecases/delete_event.dart';
import '../../domain/usecases/get_event_invitations.dart';
import '../../domain/usecases/send_event_invitations.dart';
import '../../domain/usecases/respond_to_invitation.dart';
import '../../../notifications/domain/usecases/create_notification.dart';
import '../../../notifications/domain/entities/notification.dart' as notif;

import '../../../contacts/domain/repositories/contact_repository.dart';
import '../../../groups/domain/repositories/group_repository.dart';

class EventProvider extends ChangeNotifier {
  final GetEvents getEvents;
  final GetEvent getEvent;
  final CreateEvent createEvent;
  final UpdateEvent updateEvent;
  final DeleteEvent deleteEvent;
  final GetEventInvitations getEventInvitations;
  final SendEventInvitations sendEventInvitations;
  final RespondToInvitation respondToInvitation;
  final CreateNotification createNotification;
  final ContactRepository contactRepository;
  final GroupRepository groupRepository;

  EventProvider({
    required this.getEvents,
    required this.getEvent,
    required this.createEvent,
    required this.updateEvent,
    required this.deleteEvent,
    required this.getEventInvitations,
    required this.sendEventInvitations,
    required this.respondToInvitation,
    required this.createNotification,
    required this.contactRepository,
    required this.groupRepository,
  }) {
    _loadEvents();
  }

  List<Event> _events = [];
  List<Event> get events => _events;

  Event? _currentEvent;
  Event? get currentEvent => _currentEvent;

  List<EventInvitation> _currentEventInvitations = [];
  List<EventInvitation> get currentEventInvitations => _currentEventInvitations;

  bool _isLoading = false;
  bool get isLoading => _isLoading;

  String? _error;
  String? get error => _error;

  final Map<String, String> _creatorNames = {};
  final Map<String, String> _groupNames = {};

  String? getCreatorName(String creatorId) => _creatorNames[creatorId];
  String? getGroupName(String groupId) => _groupNames[groupId];

  Future<void> fetchCreatorName(String creatorId) async {
    if (_creatorNames.containsKey(creatorId)) return;

    try {
      final contact = await contactRepository.getContact(creatorId);
      _creatorNames[creatorId] = contact.name;
      notifyListeners();
    } catch (e) {
      // Ignore error
    }
  }

  Future<void> fetchGroupName(String groupId) async {
    if (_groupNames.containsKey(groupId)) return;

    final result = await groupRepository.getGroup(groupId);
    result.fold(
      (failure) => null, // Ignore error
      (group) {
        _groupNames[groupId] = group.name;
        notifyListeners();
      },
    );
  }

  void _loadEvents() {
    _isLoading = true;
    notifyListeners();

    getEvents().listen(
      (events) {
        _events = events;
        _isLoading = false;
        _error = null;
        notifyListeners();
      },
      onError: (error) {
        _error = error.toString();
        _isLoading = false;
        notifyListeners();
      },
    );
  }

  Future<void> loadEventDetails(String eventId) async {
    _isLoading = true;
    notifyListeners();

    try {
      final event = await getEvent(eventId);
      final invitations = await getEventInvitations(eventId);

      _currentEvent = event.copyWith(invitations: invitations);
      _currentEventInvitations = invitations;
      _error = null;
    } catch (e) {
      _error = e.toString();
    } finally {
      _isLoading = false;
      notifyListeners();
    }
  }

  Future<bool> createNewEvent({
    required String name,
    required String description,
    required DateTime date,
    required String location,
    required String creatorId,
    String? groupId,
    List<String> inviteeIds = const [],
  }) async {
    _isLoading = true;
    notifyListeners();

    try {
      final event = Event(
        id: '', // Will be generated by Supabase
        name: name,
        description: description,
        date: date,
        location: location,
        creatorId: creatorId,
        groupId: groupId,
      );

      final createdEvent = await createEvent(event, inviteeIds: inviteeIds);

      // Notifications are now handled by the RPC or triggers, but if we want to keep
      // the manual notification logic for now, we can iterate and send them.
      // However, the RPC handles invitation creation.
      // The previous logic sent notifications separately.
      // Let's keep the notification logic but remove the invitation sending.

      if (inviteeIds.isNotEmpty) {
        // Create notifications for each invitee
        for (final inviteeId in inviteeIds) {
          final notification = notif.Notification(
            id: '', // Will be generated
            userId: inviteeId,
            type: 'event_invite',
            title: 'Event Invitation',
            message: 'You have been invited to "${event.name}"',
            data: {'event_id': createdEvent.id},
            read: false,
            createdAt: DateTime.now(),
          );
          await createNotification(notification);
        }
      }

      _error = null;
      _isLoading = false;
      _loadEvents(); // Refresh the list
      notifyListeners();
      return true;
    } catch (e) {
      _error = e.toString();
      _isLoading = false;
      notifyListeners();
      return false;
    }
  }

  Future<bool> updateExistingEvent(Event event) async {
    _isLoading = true;
    notifyListeners();

    try {
      await updateEvent(event);
      _error = null;
      _isLoading = false;
      notifyListeners();
      return true;
    } catch (e) {
      _error = e.toString();
      _isLoading = false;
      notifyListeners();
      return false;
    }
  }

  Future<bool> deleteExistingEvent(String eventId) async {
    _isLoading = true;
    notifyListeners();

    try {
      await deleteEvent(eventId);
      _error = null;
      _isLoading = false;
      notifyListeners();
      return true;
    } catch (e) {
      _error = e.toString();
      _isLoading = false;
      notifyListeners();
      return false;
    }
  }

  Future<bool> sendInvitations(String eventId, List<String> inviteeIds) async {
    _isLoading = true;
    notifyListeners();

    try {
      await sendEventInvitations(eventId, inviteeIds);

      // Get event details to create notifications
      final event = await getEvent(eventId);

      // Create notifications for each invitee
      for (final inviteeId in inviteeIds) {
        final notification = notif.Notification(
          id: '', // Will be generated
          userId: inviteeId,
          type: 'event_invite',
          title: 'Event Invitation',
          message: 'You have been invited to "${event.name}"',
          data: {'event_id': eventId},
          read: false,
          createdAt: DateTime.now(),
        );
        await createNotification(notification);
      }

      // Reload invitations
      await loadEventDetails(eventId);
      _error = null;
      return true;
    } catch (e) {
      _error = e.toString();
      _isLoading = false;
      notifyListeners();
      return false;
    }
  }

  Future<bool> respondToEventInvitation(
    String invitationId,
    InvitationStatus status, {
    DateTime? suggestedDate,
  }) async {
    _isLoading = true;
    notifyListeners();

    try {
      await respondToInvitation(
        invitationId,
        status,
        suggestedDate: suggestedDate,
      );
      // Reload current event details
      if (_currentEvent != null) {
        await loadEventDetails(_currentEvent!.id);
      }
      _error = null;
      return true;
    } catch (e) {
      _error = e.toString();
      _isLoading = false;
      notifyListeners();
      return false;
    }
  }

  void clearError() {
    _error = null;
    notifyListeners();
  }

  void clearCurrentEvent() {
    _currentEvent = null;
    _currentEventInvitations = [];
    notifyListeners();
  }
}
